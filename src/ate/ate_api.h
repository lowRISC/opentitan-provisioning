// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#ifndef OPENTITAN_PROVISIONING_SRC_ATE_ATE_API_H_
#define OPENTITAN_PROVISIONING_SRC_ATE_ATE_API_H_

#include <stddef.h>
#include <stdint.h>

#include <string>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DLLEXPORT
#ifdef _WIN32
#define DLLEXPORT __declspec(dllexport)
#else  // not _WIN32
#define DLLEXPORT
#endif  // _WIN32
#endif  // DLLEXPORT

enum {
  /** Maximum number of bytes allowed in the SKU specific section of the Device
     Identifier.  */
  kSkuSpecificSize = 16,

  /** Maximum token size in bytes. This is equivalent to 256 bits. */
  kTokenMaxSize = 32,

  /** SHA256 hash size in bytes. This is equivalent to 256 bits. */
  kSha256HashSize = 32,

  /** WAS HMAC signature size in bytes. This is equivalent to 256 bits. */
  kWasHmacSignatureSize = kSha256HashSize,

  /**
   * Maximum wrapped seed size in bytes. This is equivalent to the size of a
   * cyphertext generated by RSA.
   */
  kWrappedSeedMaxSize = 384,

  /** CA subject key size in bytes. This is equivalent to 160 bits. */
  kCaSubjectKeySize = 20,

  /** Maximum size of SPI frame supported by the DUT. */
  kDutSpiFrameHeaderSize = 4,
  kDutSpiFrameSize = 2048 - kDutSpiFrameHeaderSize,

  /** Maximum dev seed max size in uint32_t words. */
  kDevSeedWordSize = 32,
  kDevSeedBytesSize = kDevSeedWordSize * sizeof(uint32_t),

  /** Diversification string size. */
  kDiversificationStringSize = 48,

  /** Maximum size of a certificiate buffer in bytes. */
  kCertificateMaxSize = 2048,

  /** Maximum key label size in bytes including the nul terminator. */
  kCertificateKeyLabelMaxSize = 32,

  /**
   * Maximum perso blob (RXed from DUT and TXed to the PA/Registry) size in
   * bytes; Must be equal-to or larger than the value definited in
   * provisioning_data.h in the lowRISC/opentitan repo.
   */
  kPersoBlobMaxSize = 8192,
};

/**
 * ate_client_ptr is an opaque pointer to an AteClient instance.
 */
typedef struct {
} * ate_client_ptr;

typedef struct {
  // Endpoint address in IP or DNS format including port number. For example:
  // "localhost:5000".
  const char* pa_socket;

  // File containing the Client certificate in PEM format. Required when
  // `enable_mtls` set to true.
  const char* pem_cert_chain;

  // File containing the Client secret key in PEM format. Required when
  // `enable_mtls` set to true.
  const char* pem_private_key;

  // File containing the Server root certificates in PEM format. Required when
  // `enable_mtls` set to true.
  const char* pem_root_certs;

  // SKU authentication tokens. These tokens are considered secrets and are
  // used to perform authentication at the client gRPC call level.
  const char* sku_tokens;

  // Set to true to enable mTLS connection. When set to false, the connection
  // is established with insecure credentials.
  bool enable_mtls;
} client_options_t;

/**
 * The SPI frame is used to communicate with the DUT. The frame is divided into
 * two parts: the header and the payload. The header contains the size of the
 * payload and the payload contains the actual data.
 *
 * The header is ommitted in this struct. The ATE test framework is expected to
 * handle the header and the payload separately.
 *
 * The cursor is used to keep track of the current position in the payload.
 */
typedef struct dut_spi_frame {
  /**
   * The payload is the data to be sent to the DUT. The size of the payload is
   * limited to kDutSpiFrameSize - kDutSpiFrameHeaderSize bytes.
   */
  uint8_t payload[kDutSpiFrameSize];
  /**
   * The cursor is used to keep track of the current position in the payload.
   * The cursor is updated by the ATE test framework based on the header
   * information.
   */
  size_t cursor;
} dut_spi_frame_t;

/**
 * The perso blob is a structure used to store the personalization data.
 *
 * This structure is used to send and receive the personalization data between
 * the DUT and the ATE.
 *
 * The personalization data may include any of the following:
 * - Device ID. Sent by by the DUT to the ATE.
 * - Signature over TBS certificate data. Sent by the DUT to the ATE.
 * - To-Be-Signed (TBS) certificate data. Sent by the DUT to the ATE.
 * - Endorsed certificates. Sent by the ATE to the DUT.
 */
typedef struct perso_blob {
  /**
   * The number of objects in the blob.
   */
  size_t num_objects;
  /**
   * The offset of the next free object in the blob. Also the size in bytes.
   */
  size_t next_free;
  /**
   * The body of the blob. The size of the body is limited to 5120 bytes.
   */
  uint8_t body[kPersoBlobMaxSize];
} perso_blob_t;

/**
 * The device_id_t is a struct of data passed from secigen to ATE.
 * keep fields 4-bytes aligned.
 */
#pragma pack(push, 1)
typedef struct HardwareOrigin {
  uint16_t silicon_creator_id;
  uint16_t product_id;
  uint64_t device_identification_number;
  uint32_t cp_reserved;
} hardware_origin_t;

typedef struct DeviceId {
  hardware_origin_t hardware_origin;
  uint8_t sku_specific[kSkuSpecificSize];
} device_id_t;
#pragma pack(pop)
static_assert(sizeof(device_id_t) == 32, "device_id_t must be 32 bytes long");

typedef struct device_id_bytes {
  /**
   * Device ID used during token calculation. Unused bytes should be filled
   * with zeroes.
   */
  uint8_t raw[sizeof(device_id_t)];
} device_id_bytes_t;

/**
 * Type used to wrap diverisifer raw bytes.
 */
typedef struct diversifier_bytes {
  /**
   * Diversifier used during token calculation. Unused bytes should be filled
   * with zeroes.
   */
  uint8_t raw[kDiversificationStringSize];
} diversifier_bytes_t;

/**
 * Hash types supported by the provisioning service.
 */
typedef enum hash_type {
  /** Hash type SHA256. */
  kHashTypeSha256 = 1,
} hash_type_t;

/**
 * Curve types supported by the provisioning service.
 */
typedef enum curve_type {
  /** Curve type P256. */
  kCurveTypeP256 = 1,
} curve_type_t;

/**
 * Signature encoding types supported by the provisioning service.
 */
typedef enum signature_encoding {
  /** Signature encoding DER. */
  kSignatureEncodingDer = 1,
} signature_encoding_t;

/**
 * Endorsement certificate signature.
 *
 * The signature is a 256-bit HMAC of the endorsement certificates
 * generated by the Device Under Test. The signature is used to verify the
 * authenticity of the EndorseCerts call.
 */
typedef struct endorse_cert_signature {
  uint8_t raw[kWasHmacSignatureSize];
} endorse_cert_signature_t;

typedef struct seed {
  /**
   * The size of the seed in bytes.
   */
  size_t size;
  /**
   * The type of the seed.
   */
  size_t type;
  /**
   * The seed data.
   */
  uint8_t raw[kDevSeedBytesSize];
} seed_t;

/**
 * Request parameters for endorsing certificates.
 */
typedef struct endorse_cert_request {
  /** Hash mechanism. */
  hash_type_t hash_type;
  /** ECC Curve type. */
  curve_type_t curve_type;
  /** Signature encoding type. */
  signature_encoding_t signature_encoding;
  /** Size of the key label. */
  size_t key_label_size;
  /**
   * The key label is used to identify the key used to sign the certificate.
   * The label is a human-readable string that is used to identify the key.
   * The size of the label is limited to kCertificateKeyLabelMaxSize bytes.
   */
  char key_label[kCertificateKeyLabelMaxSize];
  /** Size of the TBS data. */
  size_t tbs_size;
  /** TBS data to sign. */
  char tbs[kCertificateMaxSize];
} endorse_cert_request_t;

/**
 * Response parameters for endorsing certificates.
 */
typedef struct endorse_cert_response {
  /** Size of the key label. */
  size_t key_label_size;
  /**
   * The key label is used to identify the key used to sign the certificate.
   * The label is a human-readable string that is used to identify the key.
   * The size of the label is limited to kCertificateKeyLabelMaxSize bytes.
   */
  char key_label[kCertificateKeyLabelMaxSize];
  /**
   * The size of the buffer pointed by `cert`. The user should set the size
   * allocated before calling the `EndorseCerts()` function. The funtion will
   * update the value with the actual certificate size.
   */
  size_t cert_size;
  /**
   * The endorsed certificate.
   */
  char cert[kCertificateMaxSize];
} endorse_cert_response_t;

/**
 * Token seed type. The seed is provisioned by the manufacturer.
 */
typedef enum token_seed {
  /** Low security seed. This seed is rotated infrequently. */
  kTokenSeedSecurityLow = 1,
  /** High security seed. This seed is rotated frequently. */
  kTokenSeedSecurityHigh = 2,
} token_seed_t;

/**
 * Token type.
 */
typedef enum token_type {
  /** Raw plaintext token. */
  kTokenTypeRaw = 1,
  /** cSHAKE128 with the "LC_CTRL" customization string. */
  kTokenTypeHashedLcToken = 2,
} token_type_t;

/**
 * Token size.
 */
typedef enum token_size {
  /** 128-bit token size. */
  kTokenSize128 = 16,
  /** 256-bit token size. */
  kTokenSize256 = 32,
} token_size_t;

/**
 * Derive token parameters.
 */
typedef struct derive_token_params {
  /** Token seed. */
  token_seed_t seed;
  /** Token type. */
  token_type_t type;
  /** Token size. */
  token_size_t size;
  /**
   * Diversifier used during token calculation. Unused bytes should be filled
   * with zeroes.
   */
  uint8_t diversifier[kDiversificationStringSize];
} derive_token_params_t;

/**
 * Generate token parameters.
 */
typedef struct generate_token_params {
  /** Token type.  */
  token_type_t type;
  /** Token size. */
  token_size_t size;
  /**
   * Diversifier used during token calculation. Unused bytes should be filled
   * with zeroes.
   */
  uint8_t diversifier[kDiversificationStringSize];
} generate_token_params_t;

/**
 * Token.
 */
typedef struct token {
  /** Token size in bytes. */
  size_t size;
  /** Token data. */
  uint8_t data[kTokenMaxSize];
} token_t;

/**
 * Wrapped token generation seed (used for RMA token generation).
 */
typedef struct wrapped_seed {
  /** Size of the wrapped seed in bytes. */
  size_t size;
  /** Seed bytes. */
  uint8_t seed[kWrappedSeedMaxSize];
} wrapped_seed_t;

/**
 * CA subject key.
 */
typedef struct ca_subject_key {
  uint8_t data[kCaSubjectKeySize];
} ca_subject_key_t;

/**
 * Type used to wrap the personalization firmware hash raw bytes.
 */
typedef struct perso_fw_sha256_hash {
  uint8_t raw[kSha256HashSize];
} perso_fw_sha256_hash_t;

/**
 * DeviceLifeCycle encodes the state of the device as it is being manufactured
 * and provisioned for shipment.
 */
typedef enum device_life_cycle : uint32_t {
  kDeviceLifeCycleUnspecified = 0,
  kDeviceLifeCycleRaw = 1,
  kDeviceLifeCycleTestLocked = 2,
  kDeviceLifeCycleTestUnlocked = 3,
  kDeviceLifeCycleDev = 4,
  kDeviceLifeCycleProd = 5,
  kDeviceLifeCycleProdEnd = 6,
  kDeviceLifeCycleRma = 7,
  kDeviceLifeCycleScrap = 8,
} device_life_cycle_t;

/**
 * OpenTitan device provisioning metadata.
 */
typedef struct metadata {
  /**
   * Year the device was provisioned.
   */
  uint32_t year;
  /**
   * Week number the device was provisioned.
   */
  uint32_t week;
  /**
   * Lot number the device came from.
   */
  uint32_t lot_num;
  /**
   * Wafer ID the device came from.
   */
  uint32_t wafer_id;
  /**
   * X position on the wafer the device came from.
   */
  uint32_t x;
  /**
   * Y position on the wafer the device came from.
   */
  uint32_t y;
} metadata_t;

/**
 * Request parameters for registering a device in the registry database.
 */
typedef struct register_device_request {
  /** Device ID. */
  uint32_t device_id[8];
  /** Device Life Cycle state. */
  device_life_cycle_t device_life_cycle;
  /** Device metadata. */
  metadata_t metadata;
  /** Encrypted RMA unlock token. */
  uint32_t wrapped_rma_unlock_token[4];
  /** Personalization TLV data. */
  uint8_t perso_tlv_data[8192];
  /** Personalization firmware SHA256 hash. */
  uint32_t perso_fw_sha256_hash[8];
} register_device_request_t;

/**
 * Creates an AteClient instance.
 *
 * The client instance should be created once and reused many times over a
 * long running session.
 *
 * @param client A pointer (an `ate_client_ptr`) to the created client instance.
 * @param options The secure channel attributes.
 */
DLLEXPORT void CreateClient(ate_client_ptr* client, client_options_t* options);

/**
 * Destroys an AteClient instance.
 *
 * @param client A client instance.
 */
DLLEXPORT void DestroyClient(ate_client_ptr client);

/**
 * initialize session for specific sku.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to initialize for.
 * @param sku_auth The SKU auth.
 * @return The result of the operation.
 */
DLLEXPORT int InitSession(ate_client_ptr client, const char* sku,
                          const char* sku_auth);

/**
 * close session for specific sku.
 *
 * @param client A client instance.
 * @return The result of the operation.
 */
DLLEXPORT int CloseSession(ate_client_ptr client);

/**
 * Derive tokens.
 *
 * The function derives tokens based on the request parameters.
 * The caller should allocate enough memory to store the result.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to derive the keys for.
 * @param count The number of tokens to derive.
 * @param params The parameters for the token derivation.
 * @param[out] keys The derived tokens. Size `count`.
 * @return The result of the operation.
 */
DLLEXPORT int DeriveTokens(ate_client_ptr client, const char* sku, size_t count,
                           const derive_token_params_t* params,
                           token_t* tokens);

/**
 * Generate tokens.
 *
 * The function generates tokens based on the request parameters.
 * The caller should allocate enough memory to store the generated tokens and
 * wrapped seeds.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to generate the keys for.
 * @param count The number of tokens to generate.
 * @param params The parameters for the token generation.
 * @param[out] tokens The generated tokens. Size `count`.
 * @param[out] seed The wrapped seed. Size `count`.
 * @return The result of the operation.
 */
DLLEXPORT int GenerateTokens(ate_client_ptr client, const char* sku,
                             size_t count,
                             const generate_token_params_t* params,
                             token_t* tokens, wrapped_seed_t* seeds);

/**
 * Gets the CA subject keys.
 *
 * This function retrieves the CA subject keys from the PA/SPM. The caller
 * should allocate enough memory to store the subject keys.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to generate the keys for.
 * @param count The number of subject keys to retrieve.
 * @param labels The lable strings of the certs to retrieve. Size `count`.
 * @param[out] key_ids The generated key_ids. Size `count`.
 * @return The result of the operation.
 */
DLLEXPORT int GetCaSubjectKeys(ate_client_ptr client, const char* sku,
                               size_t count, const char** labels,
                               ca_subject_key_t* key_ids);

/**
 * Endorse certificates.
 *
 * The function endorses certificates based on the request parameters.
 *
 * The `certs` parameter should be allocated by the caller to store the
 * endorsed certificates, and each `cert.size` field should represent the
 * allocated size of the `cert.cert` buffer.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to endorse the certificates for.
 * @param cert_count The number of certificates to endorse.
 * @param diversifier The diversification string associated with the request.
 * Used to derive the key used to verify the request signature.
 * @param signature The signature over the `tbs` certificates generated by the
 * device.
 * @param request The request parameters for the certificate endorsement.
 * @param[out] certs The endorsed certificates.
 * @return The result of the operation.
 */
DLLEXPORT int EndorseCerts(ate_client_ptr client, const char* sku,
                           const diversifier_bytes_t* diversifier,
                           const endorse_cert_signature_t* signature,
                           size_t cert_count,
                           const endorse_cert_request_t* request,
                           endorse_cert_response_t* certs);

/**
 * Register a device.
 *
 * The function registers a provisioned device in the device registry.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to endorse the certificates for.
 * @param device_life_cycle The lifecycle state the DUT was provisioned in.
 * @param metadata The metadata associated with the provisioned DUT.
 * @param wrapped_rma_unlock_token_seed The encrypted RMA unlock token seed.
 * @param perso_blob_for_registry The perso blob TLV data structure to store.
 * @param perso_fw_hash The hash of the perso firmware that was executed.
 * @return The result of the operation.
 */
DLLEXPORT int RegisterDevice(
    ate_client_ptr client, const char* sku, const device_id_t* device_id,
    device_life_cycle_t device_life_cycle, const metadata_t* metadata,
    const wrapped_seed_t* wrapped_rma_unlock_token_seed,
    const perso_blob_t* perso_blob_for_registry,
    const perso_fw_sha256_hash_t* perso_fw_hash);

/**
 * Generate JSON command to inject tokens.
 *
 * @param wafer_auth_secret The wafer auth secret.
 * @param test_unlock_token The test unlock token.
 * @param test_exit_token The test exit token.
 * @param[out] result The generated JSON command.
 * @return The result of the operation.
 */
DLLEXPORT int TokensToJson(const token_t* wafer_auth_secret,
                           const token_t* test_unlock_token,
                           const token_t* test_exit_token,
                           dut_spi_frame_t* result);

/**
 * Parse JSON command to extract device ID from the SPI frame.
 *
 * @param frame The SPI frame containing the JSON command.
 * @param[out] device_id The extracted device ID.
 * @return The result of the operation.
 */
DLLEXPORT int DeviceIdFromJson(const dut_spi_frame_t* frame,
                               device_id_bytes_t* device_id);

/**
 * Generate JSON command to inject the RMA token.
 *
 * @param rma_token The RMA token.
 * @param[out] result The generated JSON command.
 * @return The result of the operation.
 */
DLLEXPORT int RmaTokenToJson(const token_t* rma_token, dut_spi_frame_t* result);

/**
 * Parse JSON command to extract the RMA token from the SPI frame.
 *
 * @param frame The SPI frame containing the JSON command.
 * @param[out] rma_token The extracted RMA token.
 * @return The result of the operation.
 */
DLLEXPORT int RmaTokenFromJson(const dut_spi_frame_t* frame,
                               token_t* rma_token);

/**
 * Generate JSON command to inject the CA subject keys.
 *
 * @param dice_ca_sn The DICE CA subject key.
 * @param aux_ca_sn The auxiliary CA subject key.
 * @param[out] result The generated JSON command.
 * @return The result of the operation.
 */
DLLEXPORT int CaSubjectKeysToJson(const ca_subject_key_t* dice_ca_sn,
                                  const ca_subject_key_t* aux_ca_sn,
                                  dut_spi_frame_t* result);

/**
 * Generate JSON command to inject personalization blob.
 *
 * @param blob The personalization blob.
 * @param[out] result The generated JSON command.
 * @param[out] num_frames The number of SPI frames generated.
 * @return The result of the operation.
 */
DLLEXPORT int PersoBlobToJson(const perso_blob_t* blob, dut_spi_frame_t* result,
                              size_t* num_frames);

/**
 * Parse JSON command to extract personalization blob from the SPI frame.
 *
 * @param frames The SPI frames containing the JSON command.
 * @param num_frames The number of SPI frames.
 * @param[out] blob The extracted personalization blob.
 * @return The result of the operation.
 */
DLLEXPORT int PersoBlobFromJson(const dut_spi_frame_t* frames,
                                size_t num_frames, perso_blob_t* blob);

/**
 * Unpack a personalization blob into its components.
 *
 * @param blob The personalization blob to unpack.
 * @param[out] device_id The extracted device ID.
 * @param[out] hmac The HMAC over the TBS certificates.
 * @param[out] x509_tbs_certs Array of X.509 TBS certs.
 * @param[out] tbs_cert_count The number of TBS certs found. Initialized
 * to the size of `x509_tbs_certs`.
 * @param[out] x509_certs Array of (fully formed) X.509 certs.
 * @param[out] cert_count The number of certs found. Initialized to the size of
 * `x509_certs`.
 * @param[out] seeds The extracted seeds.
 * @param[out] seed_count The number of seeds found. Initialized to the size of
 * `seeds`.
 * @return The result of the operation.
 */
DLLEXPORT int UnpackPersoBlob(
    const perso_blob_t* blob, device_id_bytes_t* device_id,
    endorse_cert_signature_t* signature, endorse_cert_request_t* x509_tbs_certs,
    size_t* tbs_cert_count, endorse_cert_response_t* x509_certs,
    size_t* cert_count, seed_t* seeds, size_t* seed_count);

/**
 * Pack a personalization blob from the endorsed certificates.
 *
 * @param cert_count The number of certificates to pack.
 * @param certs The array of endorsed certificates to pack.
 * @param[out] blob The personalization blob to pack the certificates into.
 * @return The result of the operation.
 */
DLLEXPORT int PackPersoBlob(size_t cert_count,
                            const endorse_cert_response_t* certs,
                            perso_blob_t* blob);

/**
 * Pack a personalization blob containing all assets (certs and seeds) to be
 * sent to the device registry.
 *
 * @param certs_endorsed_by_dut X.509 certificates endorsed by the DUT.
 * @param num_certs_endorsed_by_dut Size of the above.
 * @param certs_endorsed_by_spm X.509 certificates endorsed by the SPM.
 * @param num_certs_endorsed_by_spm Size of the above.
 * @param seeds Seed objects generated by the DUT.
 * @param num_seeds Size of the above.
 * @param[out] blob The personalization blob to pack the assets into.
 * @return The result of the operation.
 */
DLLEXPORT int PackRegistryPersoTlvData(
    const endorse_cert_response_t* certs_endorsed_by_dut,
    size_t num_certs_endorsed_by_dut,
    const endorse_cert_response_t* certs_endorsed_by_spm,
    size_t num_certs_endorsed_by_spm, const seed_t* seeds, size_t num_seeds,
    perso_blob_t* output);

#ifdef __cplusplus
}
#endif
#endif  // OPENTITAN_PROVISIONING_SRC_ATE_ATE_API_H_
